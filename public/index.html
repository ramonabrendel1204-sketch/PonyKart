<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pony Kart Online - Custom Asset</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; touch-action: none; }
        #ui { position: absolute; inset: 0; pointer-events: none; color: white; z-index: 10; }
        .hud { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-around; font-size: 20px; font-weight: bold; text-shadow: 2px 2px #000; }
        #controls-container { position: absolute; bottom: 0; width: 100%; height: 220px; pointer-events: none; }
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 130px; height: 130px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; pointer-events: auto; }
        #knob { position: absolute; top: 40px; left: 40px; width: 50px; height: 50px; background: white; border-radius: 50%; pointer-events: none; }
        .action-btn { width: 85px; height: 85px; border: 4px solid white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; pointer-events: auto; background: #ff4081; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        #overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; pointer-events: auto; }
        .selection-box { display: flex; gap: 20px; margin: 20px; }
        .char-option { padding: 15px; border: 2px solid white; cursor: pointer; border-radius: 12px; text-align: center; width: 120px; transition: 0.3s; }
        .char-option.selected { background: #00bcd4; border-color: #00bcd4; transform: scale(1.1); }
        .btn { padding: 15px 45px; font-size: 24px; background: #00bcd4; color: white; border: none; border-radius: 40px; cursor: pointer; font-weight: bold; box-shadow: 0 0 20px rgba(0,188,212,0.5); }
        #loading-hint { font-size: 14px; margin-top: 15px; color: #aaa; }
    </style>
</head>
<body>

<div id="ui">
    <div class="hud"><div id="pos">VERBINDE...</div></div>
    <div id="controls-container">
        <div id="joystick-zone"><div id="knob"></div></div>
        <div id="jump-btn" class="action-btn" style="position: absolute; bottom: 40px; right: 40px;">SPRUNG</div>
    </div>

    <div id="overlay">
        <h1 style="color: #ff4081; letter-spacing: 2px;">PONY KART ONLINE</h1>
        <div class="selection-box">
            <div id="opt-cube" class="char-option selected" onclick="selectChar('cube')">Standard</div>
            <div id="opt-glb" class="char-option" onclick="selectChar('glb')">Custom Asset</div>
        </div>
        <button class="btn" onclick="joinGame()">RENNEN STARTEN</button>
        <p id="loading-hint">Lade 3D-Modelle...</p>
    </div>
</div>

<script>
    const socket = io();
    const loader = new THREE.GLTFLoader();
    const RADIUS = 300;
    const TRACK_WIDTH = 18;
    const PLAYER_TOP_SPEED = 0.8;
    const ACCEL = 0.015;
    const FRICTION = 0.98;
    const GRAVITY = 0.016;
    const JUMP_FORCE = 0.38;

    let scene, camera, renderer, player;
    let otherPlayers = {};
    let state = 'menu';
    let input = { x: 0, y: 0 };
    let selectedType = 'cube';
    let customModel = null;

    // Spezifischer Pfad für dein Asset
    const ASSET_PATH = 'Copilot3D-130ac2d7-a174-4c81-9c6b-432e3c7ceab2.glb';

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050512);
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 1.2));
        const light = new THREE.DirectionalLight(0xffffff, 0.8);
        light.position.set(20, 40, 20);
        scene.add(light);

        createTrack();
        loadCustomAsset();
        setupNetwork();
        setupInput();
        animate();
    }

    function loadCustomAsset() {
        loader.load(ASSET_PATH, (gltf) => {
            customModel = gltf.scene;
            document.getElementById('loading-hint').innerText = "Asset bereit!";
            document.getElementById('loading-hint').style.color = "#4caf50";
        }, (xhr) => {
            const percent = Math.round(xhr.loaded / xhr.total * 100);
            document.getElementById('loading-hint').innerText = `Lade Asset: ${percent}%`;
        }, (error) => {
            console.error("Asset konnte nicht geladen werden:", error);
            document.getElementById('loading-hint').innerText = "Custom Asset fehlt - Fallback aktiv";
        });
    }

    function createTrack() {
        const trackGeo = new THREE.RingGeometry(RADIUS - TRACK_WIDTH/2, RADIUS + TRACK_WIDTH/2, 128);
        const trackMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a, side: THREE.DoubleSide });
        const track = new THREE.Mesh(trackGeo, trackMat);
        track.rotation.x = -Math.PI / 2;
        scene.add(track);
        
        // Sterne im Hintergrund
        const starGeo = new THREE.BufferGeometry();
        const starPos = [];
        for(let i=0; i<2000; i++) starPos.push((Math.random()-0.5)*2000, (Math.random()-0.5)*2000, (Math.random()-0.5)*2000);
        starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
        scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color: 0xffffff, size: 0.8})));
    }

    function createPlayerMesh(type, color) {
        if (type === 'glb' && customModel) {
            const model = customModel.clone();
            // Automatische Skalierung und Zentrierung falls nötig
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3()).length();
            const scale = 2.5 / size;
            model.scale.set(scale, scale, scale);
            return model;
        }
        // Fallback: Einfaches Pony-Dummy
        const group = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1, 1.8), new THREE.MeshStandardMaterial({color}));
        body.position.y = 1;
        group.add(body);
        return group;
    }

    function setupNetwork() {
        socket.on('currentPlayers', (players) => {
            Object.keys(players).forEach((id) => {
                if (id !== socket.id) addOtherPlayer(players[id]);
            });
        });

        socket.on('newPlayer', (info) => addOtherPlayer(info));

        socket.on('playerMoved', (info) => {
            if (otherPlayers[info.id]) {
                const p = otherPlayers[info.id];
                p.userData.targetAngle = info.angle;
                p.userData.targetLat = info.lat;
                p.position.y = info.y || 0.8;
            }
        });

        socket.on('playerDisconnected', (id) => {
            if (otherPlayers[id]) {
                scene.remove(otherPlayers[id]);
                delete otherPlayers[id];
            }
        });
    }

    function addOtherPlayer(info) {
        const other = createPlayerMesh(info.modelType, info.color);
        other.userData = { id: info.id, targetAngle: info.angle, targetLat: info.lat };
        otherPlayers[info.id] = other;
        scene.add(other);
    }

    function selectChar(type) {
        selectedType = type;
        document.querySelectorAll('.char-option').forEach(el => el.classList.remove('selected'));
        document.getElementById('opt-' + type).classList.add('selected');
    }

    function joinGame() {
        player = createPlayerMesh(selectedType, 0xff69b4);
        player.userData = { angle: Math.PI*1.5, lat: 0, speed: 0, vY: 0, grounded: true, modelType: selectedType };
        scene.add(player);
        document.getElementById('overlay').style.display = 'none';
        state = 'racing';
    }

    function setupInput() {
        const joyZone = document.getElementById('joystick-zone');
        const knob = document.getElementById('knob');
        let joyId = null;

        joyZone.addEventListener('touchstart', (e) => { 
            joyId = e.changedTouches[0].identifier; 
        });
        
        window.addEventListener('touchmove', (e) => {
            for(let t of e.changedTouches) {
                if(t.identifier === joyId) {
                    const rect = joyZone.getBoundingClientRect();
                    const dx = t.clientX - (rect.left + rect.width/2);
                    const dy = t.clientY - (rect.top + rect.height/2);
                    const dist = Math.min(Math.hypot(dx, dy), rect.width/2);
                    const a = Math.atan2(dy, dx);
                    knob.style.transform = `translate(${Math.cos(a)*dist}px, ${Math.sin(a)*dist}px)`;
                    input.x = (Math.cos(a)*dist) / (rect.width/2);
                    input.y = -(Math.sin(a)*dist) / (rect.width/2);
                }
            }
        }, {passive: false});

        window.addEventListener('touchend', () => { 
            knob.style.transform = 'translate(0,0)'; 
            input.x = 0; input.y = 0; 
            joyId = null; 
        });

        document.getElementById('jump-btn').addEventListener('touchstart', (e) => {
            e.preventDefault();
            if(player && player.userData.grounded) { 
                player.userData.vY = JUMP_FORCE; 
                player.userData.grounded = false; 
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        if (state === 'racing' && player) {
            const d = player.userData;
            if(input.y > 0.1) d.speed = Math.min(d.speed + ACCEL, PLAYER_TOP_SPEED);
            else d.speed *= FRICTION;

            d.angle += d.speed / RADIUS;
            d.lat = THREE.MathUtils.clamp(d.lat - input.x * 0.45, -TRACK_WIDTH/2+1, TRACK_WIDTH/2-1);
            
            d.vY -= GRAVITY;
            player.position.y += d.vY;
            if(player.position.y <= 0.8) { player.position.y = 0.8; d.vY = 0; d.grounded = true; }

            const r = RADIUS + d.lat;
            player.position.set(Math.cos(d.angle)*r, player.position.y, Math.sin(d.angle)*r);
            player.lookAt(Math.cos(d.angle+0.1)*r, player.position.y, Math.sin(d.angle+0.1)*r);

            socket.emit('playerMovement', { 
                angle: d.angle, 
                lat: d.lat, 
                speed: d.speed, 
                y: player.position.y,
                modelType: d.modelType
            });

            const camPos = new THREE.Vector3(0, 5, -12).applyMatrix4(player.matrixWorld);
            camera.position.lerp(camPos, 0.1);
            camera.lookAt(player.position);
        }

        // Interpolation für flüssige Bewegungen anderer Spieler
        Object.values(otherPlayers).forEach(p => {
            const d = p.userData;
            if(d.targetAngle !== undefined) {
                d.angle = d.angle || d.targetAngle;
                d.lat = d.lat || d.targetLat;
                d.angle = THREE.MathUtils.lerp(d.angle, d.targetAngle, 0.1);
                d.lat = THREE.MathUtils.lerp(d.lat, d.targetLat, 0.1);
                const r = RADIUS + d.lat;
                p.position.set(Math.cos(d.angle)*r, p.position.y, Math.sin(d.angle)*r);
                p.lookAt(Math.cos(d.angle+0.05)*r, p.position.y, Math.sin(d.angle+0.05)*r);
            }
        });

        renderer.render(scene, camera);
        if(socket.connected) {
            document.getElementById('pos').innerText = `SPIELER ONLINE: ${Object.keys(otherPlayers).length + 1}`;
        }
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight; 
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
</script>
</body>
</html>

